// Code generated by go-bluetooth generator DO NOT EDIT.

package obex

import (
	"sync"

	"github.com/godbus/dbus/v5"
	"github.com/muka/go-bluetooth/bluez"
	"github.com/muka/go-bluetooth/props"
	"github.com/muka/go-bluetooth/util"
)

var MessageAccess1Interface = "org.bluez.obex.MessageAccess1"

// NewMessageAccess1 create a new instance of MessageAccess1
//
// Args:
// - objectPath: [Session object path]
func NewMessageAccess1(objectPath dbus.ObjectPath) (*MessageAccess1, error) {
	a := new(MessageAccess1)
	a.client = bluez.NewClient(
		&bluez.Config{
			Name:  "org.bluez.obex",
			Iface: MessageAccess1Interface,
			Path:  dbus.ObjectPath(objectPath),
			Bus:   bluez.SystemBus,
		},
	)
	a.Properties = new(MessageAccess1Properties)

	_, err := a.GetProperties()
	if err != nil {
		return nil, err
	}
	return a, nil
}

/*
MessageAccess1 BlueZ D-Bus OBEX MessageAccess API documentation
*/
type MessageAccess1 struct {
	client                 *bluez.Client
	propertiesSignal       chan *dbus.Signal
	objectManagerSignal    chan *dbus.Signal
	objectManager          *bluez.ObjectManager
	Properties             *MessageAccess1Properties
	watchPropertiesChannel chan *dbus.Signal
}

// MessageAccess1Properties contains the exposed properties of an interface
type MessageAccess1Properties struct {
	lock sync.RWMutex `dbus:"ignore"`
}

// Lock access to properties
func (p *MessageAccess1Properties) Lock() {
	p.lock.Lock()
}

// Unlock access to properties
func (p *MessageAccess1Properties) Unlock() {
	p.lock.Unlock()
}

// Close the connection
func (a *MessageAccess1) Close() {
	a.unregisterPropertiesSignal()
	a.client.Disconnect()
}

// Path return MessageAccess1 object path
func (a *MessageAccess1) Path() dbus.ObjectPath {
	return a.client.Config.Path
}

// Client return MessageAccess1 dbus client
func (a *MessageAccess1) Client() *bluez.Client {
	return a.client
}

// Interface return MessageAccess1 interface
func (a *MessageAccess1) Interface() string {
	return a.client.Config.Iface
}

// GetObjectManagerSignal return a channel for receiving updates from the ObjectManager
func (a *MessageAccess1) GetObjectManagerSignal() (chan *dbus.Signal, func(), error) {

	if a.objectManagerSignal == nil {
		if a.objectManager == nil {
			om, err := bluez.GetObjectManager()
			if err != nil {
				return nil, nil, err
			}
			a.objectManager = om
		}

		s, err := a.objectManager.Register()
		if err != nil {
			return nil, nil, err
		}
		a.objectManagerSignal = s
	}

	cancel := func() {
		if a.objectManagerSignal == nil {
			return
		}
		a.objectManagerSignal <- nil
		a.objectManager.Unregister(a.objectManagerSignal)
		a.objectManagerSignal = nil
	}

	return a.objectManagerSignal, cancel, nil
}

// ToMap convert a MessageAccess1Properties to map
func (a *MessageAccess1Properties) ToMap() (map[string]interface{}, error) {
	return props.ToMap(a), nil
}

// FromMap convert a map to an MessageAccess1Properties
func (a *MessageAccess1Properties) FromMap(props map[string]interface{}) (*MessageAccess1Properties, error) {
	props1 := map[string]dbus.Variant{}
	for k, val := range props {
		props1[k] = dbus.MakeVariant(val)
	}
	return a.FromDBusMap(props1)
}

// FromDBusMap convert a map to an MessageAccess1Properties
func (a *MessageAccess1Properties) FromDBusMap(props map[string]dbus.Variant) (*MessageAccess1Properties, error) {
	s := new(MessageAccess1Properties)
	err := util.MapToStruct(s, props)
	return s, err
}

// ToProps return the properties interface
func (a *MessageAccess1) ToProps() bluez.Properties {
	return a.Properties
}

// GetWatchPropertiesChannel return the dbus channel to receive properties interface
func (a *MessageAccess1) GetWatchPropertiesChannel() chan *dbus.Signal {
	return a.watchPropertiesChannel
}

// SetWatchPropertiesChannel set the dbus channel to receive properties interface
func (a *MessageAccess1) SetWatchPropertiesChannel(c chan *dbus.Signal) {
	a.watchPropertiesChannel = c
}

// GetProperties load all available properties
func (a *MessageAccess1) GetProperties() (*MessageAccess1Properties, error) {
	a.Properties.Lock()
	err := a.client.GetProperties(a.Properties)
	a.Properties.Unlock()
	return a.Properties, err
}

// SetProperty set a property
func (a *MessageAccess1) SetProperty(name string, value interface{}) error {
	return a.client.SetProperty(name, value)
}

// GetProperty get a property
func (a *MessageAccess1) GetProperty(name string) (dbus.Variant, error) {
	return a.client.GetProperty(name)
}

// GetPropertiesSignal return a channel for receiving udpdates on property changes
func (a *MessageAccess1) GetPropertiesSignal() (chan *dbus.Signal, error) {

	if a.propertiesSignal == nil {
		s, err := a.client.Register(a.client.Config.Path, bluez.PropertiesInterface)
		if err != nil {
			return nil, err
		}
		a.propertiesSignal = s
	}

	return a.propertiesSignal, nil
}

// Unregister for changes signalling
func (a *MessageAccess1) unregisterPropertiesSignal() {
	if a.propertiesSignal != nil {
		a.propertiesSignal <- nil
		a.propertiesSignal = nil
	}
}

// WatchProperties updates on property changes
func (a *MessageAccess1) WatchProperties() (chan *bluez.PropertyChanged, error) {
	return bluez.WatchProperties(a)
}

func (a *MessageAccess1) UnwatchProperties(ch chan *bluez.PropertyChanged) error {
	return bluez.UnwatchProperties(a, ch)
}

/*
SetFolder Set working directory for current session.

	Possible name:

		Directory name or '..[/dir]'.

	Possible errors:

	:org.bluez.obex.Error.InvalidArguments:
	:org.bluez.obex.Error.Failed:
*/
func (a *MessageAccess1) SetFolder(name string) error {
	return a.client.Call("SetFolder", 0, name).Store()
}

/*
ListFolders Returns a dictionary containing information about the current folder

	content.

	Possible filter:

	:uint16 Offset (default 0):

		Offset of the first item.

	:uint16 MaxCount (default 1024):

		Maximum number of items.

	Possible return:

	:string Name:

		Folder name

	Possible errors:

	:org.bluez.obex.Error.InvalidArguments:
	:org.bluez.obex.Error.Failed:
*/
func (a *MessageAccess1) ListFolders(filter map[string]interface{}) ([]map[string]interface{}, error) {
	val0 := []map[string]interface{}{}
	err := a.client.Call("ListFolders", 0, filter).Store(&val0)
	return val0, err
}

/*
ListFilterFields Return all available fields that can be used in **Fields** filter.

	Possible values:

	:"subject":
	:"timestamp":
	:"sender":
	:"sender-address":
	:"recipient":
	:"recipient-address":
	:"type":
	:"size":
	:"status":
	:"text":
	:"attachment":
	:"priority":
	:"read":
	:"sent":
	:"protected":
	:"replyto":

	Possible errors: None
*/
func (a *MessageAccess1) ListFilterFields() ([]string, error) {
	val0 := []string{}
	err := a.client.Call("ListFilterFields", 0).Store(&val0)
	return val0, err
}

/*
ListMessages Returns an array containing the messages objects found in the given

	subfolder of the current folder, or in the current folder if folder is
	empty.

	Possible Filters:

	:uint16 Offset (default 0):

		Offset of the first item.

	uint16 MaxCount (default 1024):

		Maximum number of items.

	:byte SubjectLength (default 256):

		Maximum length of the Subject property in the message.

	:array{string} Fields:

		Message fields, default is all values.

		See **ListFilterFields()** for possible values.

	:array{string} Types:

		Filter messages by type.

		Possible values:

		:"sms":
		:"email":
		:"mms":

	:string PeriodBegin:

		Filter messages by starting period.

		Possible values:

			Date in "YYYYMMDDTHHMMSS" format.

	:string PeriodEnd:

		Filter messages by ending period.

		Possible values:

			Date in "YYYYMMDDTHHMMSS" format.

	:boolean Read:

		Filter messages by read flag.

		Possible values:

			True for read or False for unread

	:string Recipient:

		Filter messages by recipient address.

	:string Sender:

		Filter messages by sender address.

	:boolean Priority:

		Filter messages by priority flag.

		Possible values:

			True for high priority or False for non-high priority.

	Each message is represented by an object path, which implements
	**org.bluez.obex.Message(5)** interface, followed by a dictionary
	of its properties.
*/
func (a *MessageAccess1) ListMessages(folder string, filter map[string]interface{}) ([]Message, error) {
	val0 := []Message{}
	err := a.client.Call("ListMessages", 0, folder, filter).Store(&val0)
	return val0, err
}

/*
PushMessage Transfers a message (in bMessage format) to the remote device.

	The message is transferred either to the given subfolder of the current
	folder, or to the current folder if folder is empty.

	Possible args: Transparent, Retry, Charset

	The returned path represents the newly created transfer, which should be
	used to find out if the content has been successfully transferred or if
	the operation fails.

	The properties of this transfer are also returned along with the object
	path, to avoid a call to GetProperties, see
	**org.bluez.obex.Transfer(5)** for the possible list of properties.

	Possible errors:

	:org.bluez.obex.Error.InvalidArguments:
*/
func (a *MessageAccess1) PushMessage(sourcefile string, folder string, args map[string]interface{}) (dbus.ObjectPath, map[string]interface{}, error) {
	var val0 dbus.ObjectPath
	var val1 map[string]interface{}
	err := a.client.Call("PushMessage", 0, sourcefile, folder, args).Store(&val0, &val1)
	return val0, val1, err
}
